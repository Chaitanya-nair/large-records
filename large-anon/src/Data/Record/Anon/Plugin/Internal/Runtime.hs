{-# LANGUAGE ConstraintKinds        #-}
{-# LANGUAGE DataKinds              #-}
{-# LANGUAGE FlexibleInstances      #-}
{-# LANGUAGE FunctionalDependencies #-}
{-# LANGUAGE GADTs                  #-}
{-# LANGUAGE MultiParamTypeClasses  #-}
{-# LANGUAGE PolyKinds              #-}
{-# LANGUAGE RankNTypes             #-}
{-# LANGUAGE TypeFamilies           #-}

{-# OPTIONS_HADDOCK hide #-}

-- | Runtime for code generated by the plugin
--
-- Users should not need to import from this module directly.
module Data.Record.Anon.Plugin.Internal.Runtime (
    -- * Row
    Pair(..)
  , Row
    -- * RecordHasField
  , RecordHasField(..)
  , evidenceRecordHasField
    -- * Term-level metadata
  , KnownFields(..)
  , DictKnownFields
  , evidenceKnownFields
  , fieldMetadata
    -- * Type-level metadata
  , FieldTypes
  , SimpleFieldTypes
    -- * AllFields
  , AllFields(..)
  , DictAny(..)
  , DictAllFields
  , evidenceAllFields
    -- * KnownHash
  , KnownHash(..)
  , evidenceKnownHash
    -- * Merging
  , Merge
    -- * Subrecords
  , Project(..)
  , DictProject
  , evidenceProject
    -- * Utility
  , noInlineUnsafeCo
  ) where

import Data.Kind
import Data.Record.Generic hiding (FieldName)
import Data.SOP.Constraint (Compose)
import GHC.Exts (Any)
import GHC.TypeLits
import Unsafe.Coerce (unsafeCoerce)

import Data.Record.Anon.Core.FieldName
import Data.Record.Anon.Core.Record

import qualified Data.Record.Anon.Core.Record as Record
import qualified Data.Vector as Lazy
import qualified Data.Vector as Vector

{-------------------------------------------------------------------------------
  IMPLEMENTATION NOTE

  Support for name resolution in typechecker plugins is a bit rudimentary. The
  only available API is

  > lookupOrig :: Module -> OccName -> TcPluginM Name

  This function can /only/ be used to look things up in the given module that
  are /defined by/ that module; it won't find anything that is merely /exported/
  by the module. This makes name lookup brittle: an internal re-organization
  that changes where things are defined might break the plugin, even if the
  export lists of those modules have not changed. This is merely annoying for
  internal reshuffling, but worse for external reshuffling as such changes would
  be considered entirely backwards compatible and not require any major version
  changes.

  We address this in two ways:

  1. Anything defined internally in this package that needs to be referred by the
     plugin is defined in here in this @.Runtime@ module. This does have the
     unfortunate consequence that this module contains definitions that are not
     necessarily related to each other, apart from "required by the plugin".
  2. We avoid dependencies on external packages altogether. For example, instead
     of the plugin providing evidence for 'HasField' directly, it instead
     provides evidence for a 'HasField'-like class defined here in the
     @.Runtime@ module. We then give a "forwarding" instance for the " real "
     'HasField' in terms of that class; the plugin does not need to be aware of
     that forwarding instance, of course, and it won't be done in this module.

  Avoiding any external dependencies here has an additional advantage: even if
  we accept that the plugin must specifiy the exact module where something is
  defined in an external package, there is a secondary problem: users who then
  use the plugin must declare those packages as explicit dependencies, or else
  name resolution will fail at compile time (of the user's package) with a
  mysterious error message. It may be possible to work around this problem by
  using something else instead of @findImportedModule@, but avoiding external
  dependencies just bypasses the problem altogether.

  NOTE: In order to avoid headaches with cyclic module dependencies, we use the
  convention that the runtime can only import from @Data.Record.Anon.Core.*@,
  which in turn cannot import from the runtime (and can only import from other
  modules in the Core.*@). One important consequence of this split is that
  nothing in @Core.*@ is aware of the concept of rows, which is introduced here.
-------------------------------------------------------------------------------}

{-------------------------------------------------------------------------------
  Row
-------------------------------------------------------------------------------}

-- | Pair of values
--
-- This is used exclusively promoted to the type level, in 'Row'.
data Pair a b = a := b

-- | Row: type-level list of field names and corresponding field types
type Row k = [Pair Symbol k]

{-------------------------------------------------------------------------------
  HasField
-------------------------------------------------------------------------------}

-- | Specialized form of 'HasField'
--
-- @RecordHasField n f r a@ holds if there is an @(n := a)@ in @r@.
class RecordHasField (n :: Symbol)
                     (f :: k -> Type)
                     (r :: Row k)
                     (a :: Type) | n r -> a where
  -- Implementation note: We use this more specialized form of 'HasField'
  -- instead of a straight copy of 'HasField', so that the plugin does not need
  -- to ever the 'Record' type constructor (if it did, it would need to be
  -- defined here in this module, which would be annoying).
  recordHasField :: DictRecordHasField k n f r a
  recordHasField = undefined

type DictRecordHasField k (n :: Symbol) (f :: k -> Type) (r :: Row k) a =
  forall proxy proxy'. proxy n -> proxy' r -> Record f -> (a -> Record f, a)

-- | Evidence for 'HasField'
--
-- Precondition: the record must have the specified field with type @a@ (where
-- @a@ will be of the form @f a'@ for some @a'@). This precondition is verified
-- by the plugin before generating "evidence" that uses this function.
evidenceRecordHasField :: forall k (n :: Symbol) (f :: k -> Type) (r :: Row k) a.
     Int           -- ^ Field index
  -> (Int, String) -- ^ Field name and hash
  -> DictRecordHasField k n f r a
evidenceRecordHasField i n _proxyN _proxyR r = (
      \x -> Record.setField i n' x r
    ,       Record.getField i n'   r
    )
  where
    n' :: FieldName
    n' = uncurry FieldName n

{-------------------------------------------------------------------------------
  Term-level metadata

  NOTE: Here and elsewhere, we provide an (undefined) default implementation,
  to avoid the method showing up in the Haddocks. In practice this makes no
  difference: the body of the class is not exported, and instances are instead
  computed by the plugin.
-------------------------------------------------------------------------------}

-- | Require that all field names in @r@ are known
class KnownFields (r :: Row k) where
  fieldNames :: DictKnownFields k r
  fieldNames = undefined

type DictKnownFields k (r :: Row k) =
       forall proxy. proxy r -> [String]

evidenceKnownFields :: forall k (r :: Row k).
  [String] -> DictKnownFields k r
evidenceKnownFields x _ = x

{-------------------------------------------------------------------------------
  Type-level metadata
-------------------------------------------------------------------------------}

-- | Type-level metadata
--
-- >    FieldTypes Maybe [ "a" := Int, "b" := Bool ]
-- > == [ '("a", Maybe Int), '("b", Maybe Bool) ]
type family FieldTypes (f :: k -> Type) (r :: Row k) :: [(Symbol, Type)]

-- | Like 'FieldTypes', but for the simple API (no functor argument)
--
-- >    SimpleFieldTypes [ "a" := Int, "b" := Bool ]
-- > == [ '("a", Int), '("b", Bool) ]
type family SimpleFieldTypes (r :: Row Type) :: [(Symbol, Type)]

{-------------------------------------------------------------------------------
  AllFields
-------------------------------------------------------------------------------}

-- | Require that @c x@ holds for every @(n := x)@ in @r@.
class AllFields (r :: Row k) (c :: k -> Constraint) where
  -- | Vector of dictionaries, in row order
  --
  -- This returns a /lazy/ vector because it is used to build a 'Rep'.
  fieldDicts :: DictAllFields k r c
  fieldDicts = undefined

type DictAllFields k (r :: Row k) (c :: k -> Constraint) =
       forall proxy proxy'. proxy r -> proxy' c -> Lazy.Vector (DictAny c)

data DictAny c where
  DictAny :: c Any => DictAny c

evidenceAllFields :: forall k (r :: Row k) (c :: k -> Constraint).
  [DictAny c] -> DictAllFields k r c
evidenceAllFields x _ _ = Vector.fromList x

instance {-# OVERLAPPING #-}
         (KnownFields r, Show a)
      => AllFields r (Compose Show (K a)) where
  fieldDicts pr _ = Lazy.fromList $ map (const DictAny) (fieldNames pr)

instance {-# OVERLAPPING #-}
         (KnownFields r, Eq a)
      => AllFields r (Compose Eq (K a)) where
  fieldDicts pr _ = Lazy.fromList $ map (const DictAny) (fieldNames pr)

instance {-# OVERLAPPING #-}
         (KnownFields r, Ord a)
      => AllFields r (Compose Ord (K a)) where
  fieldDicts pr _ = Lazy.fromList $ map (const DictAny) (fieldNames pr)

fieldMetadata :: forall k (r :: Row k) proxy.
     KnownFields r
  => proxy r -> [FieldMetadata Any]
fieldMetadata = map aux . fieldNames
  where
    -- @large-anon@ only supports records with strict fields.
    aux :: String -> FieldMetadata Any
    aux name = case someSymbolVal name of
                 SomeSymbol p -> FieldMetadata p FieldStrict

{-------------------------------------------------------------------------------
  Merging records
-------------------------------------------------------------------------------}

-- | Merge two rows
--
-- See 'Data.Record.Anon.Advanced.merge' for detailed discussion.
type family Merge :: Row k -> Row k -> Row k

{-------------------------------------------------------------------------------
  KnownHash

  This class is exported /with/ its body from the library (no reason not to).
  so we avoid using 'DictKnownHash' in the class definition.
-------------------------------------------------------------------------------}

-- | Symbol (type-level string) with compile-time computed hash
--
-- Instances are computed on the fly by the plugin.
class KnownHash (s :: Symbol) where
  hashVal :: forall proxy. proxy s -> Int

type DictKnownHash (s :: Symbol) =
       forall proxy. proxy s -> Int

evidenceKnownHash :: forall (s :: Symbol).
  Int -> DictKnownHash s
evidenceKnownHash x _ = x

{-------------------------------------------------------------------------------
  Subrecord
-------------------------------------------------------------------------------}

-- | Subrecords
--
-- If @Project f r r'@ holds, we can project (or create a lens) @r@ to @r'@.
-- See 'Data.Record.Anon.Advanced.project' for detailed discussion.
class Project (f :: k -> Type) (r :: Row k) (r' :: Row k) where
  projectIndices :: DictProject k f r r'
  projectIndices = undefined

-- | In order of the fields in the /target/ record, the index in the /source/
type DictProject k (f :: k -> Type) (r :: Row k) (r' :: Row k) =
       Proxy f -> Proxy r -> Proxy r' -> [Int]

evidenceProject :: forall k (f :: k -> Type) (r :: Row k) (r' :: Row k).
  [Int] -> DictProject k f r r'
evidenceProject x _ _ _ = x

{-------------------------------------------------------------------------------
  Utility
-------------------------------------------------------------------------------}

-- TODO: It might be nice if we could use this throughout, and avoid using the
-- one from LR.
noInlineUnsafeCo :: a -> b
{-# NOINLINE noInlineUnsafeCo #-}
noInlineUnsafeCo = unsafeCoerce
