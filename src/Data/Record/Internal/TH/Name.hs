{-# LANGUAGE DataKinds             #-}
{-# LANGUAGE DerivingVia           #-}
{-# LANGUAGE FlexibleContexts      #-}
{-# LANGUAGE FlexibleInstances     #-}
{-# LANGUAGE GADTs                 #-}
{-# LANGUAGE KindSignatures        #-}
{-# LANGUAGE PartialTypeSignatures #-}
{-# LANGUAGE ScopedTypeVariables   #-}
{-# LANGUAGE StandaloneDeriving    #-}
{-# LANGUAGE TypeApplications      #-}

{-# OPTIONS_GHC -Wno-partial-type-signatures #-}

-- | Names with statically known flavour
--
-- Intended for qualified import.
module Data.Record.Internal.TH.Name (
    -- * Names
    Flavour(..)
  , NameFlavour(..)
  , NameSpace(..)
  , Name(..)
  , nameBase
    -- ** Singleton
  , SFlavour(..)
  , IsFlavour(..)
    -- ** Conversion
  , fromName
  , fromName'
  , toName
    -- * Overloaded names
  , OverloadedName(..)
  , fromOverloaded
    -- * Resolution
  , LookupName(..)
  , lookupKnownName
  , reify
    -- * Derive unique names
  , DemoteNameSpace(..)
  , deriveUnique
    -- * Construction
  , prefixNew
  , prefixExisting
    -- * Abstract over different kinds of names
  , IsName(..)
    -- * Metadata
  , ExtractMetadata(..)
    -- * Construct TH
  , classD
  , conE
  , conT
  , newtypeD
  , patSynD
  , patSynSigD
  , pragCompleteD
  , recC
  , recordPatSyn
  , sigD
  , varBangType
  , varE
  , varP
  ) where

import Data.Kind
import Data.Maybe (fromMaybe)
import Data.Proxy
import Language.Haskell.TH (Q)
import Language.Haskell.TH.Syntax (Quasi, runQ, NameSpace(..))

import qualified Language.Haskell.TH.Syntax as TH
import qualified Language.Haskell.TH.Lib    as TH

{-------------------------------------------------------------------------------
  Names
-------------------------------------------------------------------------------}

-- | Name flavours (used as a kind, not as a type)
--
-- Technically speaking there is one flavour missing: names that are locally
-- bound, but outside of the TH quote, something like
--
-- > foo x = [| .. x .. |]
--
-- However, we won't actually deal with such names.
data Flavour =
    -- | Dynamically bound
    --
    -- Dynamically bound names will be bound to a global name by @ghc@ after
    -- splicing the TH generated Haskelll code.
    --
    -- These are generated with 'mkName' (also used by @haskell-src-meta@).
    Dynamic

    -- | A new name
    --
    -- These are names either generated by 'newName' or are new names in a TH
    -- declaration quote @[d| ... |]@.
  | Unique

    -- | Reference to a specific name defined outside of the TH quote
  | Global

data NameFlavour :: Flavour -> Type where
  -- | Dynamically bound name, with an optional module prefix (@T.foo@)
  NameDynamic :: Maybe TH.ModName -> NameFlavour 'Dynamic

  -- | Unique local name
  NameUnique :: TH.Uniq -> NameFlavour 'Unique

  -- | Global name bound outside of the TH quot
  NameGlobal :: TH.NameSpace -> TH.PkgName -> TH.ModName -> NameFlavour 'Global

-- | Like TH's 'Name', but with statically known flavour.
data Name :: NameSpace -> Flavour -> Type where
  Name :: TH.OccName -> NameFlavour flavour -> Name ns flavour

deriving instance Show (NameFlavour flavour)
deriving instance Eq   (NameFlavour flavour)
deriving instance Ord  (NameFlavour flavour)

deriving instance Show (Name ns flavour)
deriving instance Eq   (Name ns flavour)
deriving instance Ord  (Name ns flavour)

nameBase :: Name ns flavour -> String
nameBase (Name (TH.OccName occ) _) = occ

{-------------------------------------------------------------------------------
  Singleton
-------------------------------------------------------------------------------}

-- | Singleton type associated with 'Flavour'
data SFlavour :: Flavour -> Type where
  SDynamic :: SFlavour 'Dynamic
  SUnique  :: SFlavour 'Unique
  SGlobal  :: SFlavour 'Global

deriving instance Show (SFlavour flavour)

class IsFlavour flavour where
  isFlavour :: SFlavour flavour

instance IsFlavour 'Dynamic where isFlavour = SDynamic
instance IsFlavour 'Unique  where isFlavour = SUnique
instance IsFlavour 'Global  where isFlavour = SGlobal

{-------------------------------------------------------------------------------
  Conversion
-------------------------------------------------------------------------------}

toFlavourF :: SFlavour flavour -> TH.NameFlavour -> Maybe (NameFlavour flavour)
toFlavourF SDynamic (TH.NameS)       = Just $ NameDynamic Nothing
toFlavourF SDynamic (TH.NameQ m)     = Just $ NameDynamic (Just m)
toFlavourF SUnique  (TH.NameU u)     = Just $ NameUnique u
toFlavourF SGlobal  (TH.NameG n p m) = Just $ NameGlobal n p m
toFlavourF _        _                = Nothing

fromFlavourF :: NameFlavour flavour -> TH.NameFlavour
fromFlavourF (NameDynamic Nothing)  = TH.NameS
fromFlavourF (NameDynamic (Just m)) = TH.NameQ m
fromFlavourF (NameUnique u)         = TH.NameU u
fromFlavourF (NameGlobal n p m)     = TH.NameG n p m

-- | Translate from a dynamically typed TH name
--
-- Returns 'Nothing' if the TH name does not have the specified flavour.
fromName :: IsFlavour flavour => TH.Name -> Maybe (Name ns flavour)
fromName (TH.Name occ flavour') =
    Name occ <$> toFlavourF isFlavour flavour'

-- | Variation on 'fromName' that throws an exception on a flavour mismatch
fromName' :: forall ns flavour. IsFlavour flavour => TH.Name -> Name ns flavour
fromName' name@(TH.Name occ flavour') =
    fromMaybe (error err) $ fromName name
  where
    err :: String
    err = concat [
          "fromName': name "
        , show occ
        , " has the wrong flavour: "
        , show (isFlavour :: SFlavour flavour)
        , " /= "
        , show flavour'
        ]

-- | Forget type level information
toName :: Name ns flavour -> TH.Name
toName (Name occ flavour) = TH.Name occ (fromFlavourF flavour)

{-------------------------------------------------------------------------------
  Overloaded names
-------------------------------------------------------------------------------}

-- | Overloaded name
--
-- Overloaded names only have an interpretation in context; for example, a
-- field name only means something when combined with type of the /record/ the
-- field belongs to.
--
-- We treat this as a completely separate category, because 'OverloadedName's
-- do not correspond to TH 'Name's.
newtype OverloadedName = OverloadedName {
      getOverloadedName :: String
    }
  deriving (Show, Eq, Ord)

-- | Construct 'Name' from an 'OverloadedName'
--
-- WARNING: The moment you do this, you lose overloading: using 'fromOverloaded'
-- to bind definitions for two fields with the same name will result in two
-- identical names within the same scope, and hence a "multiple declarations"
-- error.
fromOverloaded :: OverloadedName -> Name ns 'Dynamic
fromOverloaded (OverloadedName n) = mkName n

{-------------------------------------------------------------------------------
  Resolution
-------------------------------------------------------------------------------}

class LookupName ns where
  -- | Resolve existing name
  lookupName :: Quasi m => Name ns 'Dynamic -> m (Maybe (Name ns 'Global))

instance LookupName 'TcClsName where
  lookupName (Name occ (NameDynamic mMod)) =
      fmap fromName' <$>
        runQ (TH.lookupTypeName $ qualify mMod occ)

instance LookupName 'DataName where
  lookupName (Name occ (NameDynamic mMod)) =
      fmap fromName' <$>
        runQ (TH.lookupValueName $ qualify mMod occ)

instance LookupName 'VarName where
  lookupName (Name occ (NameDynamic mMod)) =
      fmap fromName' <$>
        runQ (TH.lookupValueName $ qualify mMod occ)

-- | Wrapper around 'lookupName' that expects the name to be known, and fails
-- if it's not.
lookupKnownName ::
     ( Quasi m
     , LookupName ns
     , IsName (Name ns 'Dynamic)
     )
  => Name ns 'Dynamic -> m (Name ns 'Global)
lookupKnownName n = do
    mn' <- lookupName n
    case mn' of
      Nothing -> fail $ "lookupKnownName: " ++ showName n ++ " not in scope"
      Just n' -> return n'

-- | Get info about the given name
--
-- Only global names can be reified. See 'lookupName'.
reify :: Quasi m => Name ns 'Global -> m TH.Info
reify = runQ . TH.reify . toName

{-------------------------------------------------------------------------------
  Derive unique names
-------------------------------------------------------------------------------}

class DemoteNameSpace (ns :: NameSpace) where
  demoteNameSpace :: Proxy ns -> NameSpace

instance DemoteNameSpace 'TcClsName where demoteNameSpace _ = TcClsName
instance DemoteNameSpace 'DataName  where demoteNameSpace _ = DataName
instance DemoteNameSpace 'VarName   where demoteNameSpace _ = VarName

-- | Convert 'Unique name (with fresh names) to a 'Global name
-- (the fully qualified name), given the context of the name
mkUniqueName :: forall ns.
     DemoteNameSpace ns
  => TH.PkgName -> TH.ModName -> Name ns 'Unique -> Name ns 'Global
mkUniqueName pkg modl (Name occ (NameUnique _uniq)) =
    Name occ (NameGlobal (demoteNameSpace (Proxy @ns)) pkg modl)

-- | Derive unique name
--
-- NOTE: Names with a 'Unique' flavour are spliced into the current module.
-- We can turn these into 'Global' names by looking up what the current module
-- /is/, but this means we should be careful when we call this function.
deriveUnique :: forall m ns.
     (Quasi m, DemoteNameSpace ns)
  => Name ns 'Unique -> m (Name ns 'Global)
deriveUnique = \n -> flip aux n <$> runQ TH.location
  where
    aux :: TH.Loc -> Name ns 'Unique -> Name ns 'Global
    aux l = mkUniqueName
              (TH.mkPkgName (TH.loc_package l))
              (TH.mkModName (TH.loc_module  l))

{-------------------------------------------------------------------------------
  Construction
-------------------------------------------------------------------------------}

newName :: String -> Q (Name ns 'Unique)
newName = fmap fromName' . TH.newName

mkName :: String -> Name ns 'Dynamic
mkName = fromName' . TH.mkName

-- | Construct a new (dynamically bound) name by prefixing another name
--
-- Only the base name ('OccName') of the input name will be used.
prefixNew :: String -> Name ns flavour -> Name ns' 'Dynamic
prefixNew prefix (Name (TH.OccName occ) _flavour) =
      Name (TH.OccName (prefix ++ occ)) (NameDynamic Nothing)

-- | Prefix existing name
--
-- When we prefix an existing name, we want to use the package/module
-- info of the existing name, but not necessarily it's namespace: we might
-- well be deriving, say, a function name from a type name.
prefixExisting :: String -> TH.NameSpace -> Name ns 'Global -> Name ns' 'Global
prefixExisting prefix n (Name (TH.OccName occ) (NameGlobal _ p m)) =
      Name (TH.OccName (prefix ++ occ)) (NameGlobal n p m)

{-------------------------------------------------------------------------------
  Abstract over different kinds of names
-------------------------------------------------------------------------------}

-- | Regular or overloaded names
class IsName n where
  -- | Make a fresh name derived from another name
  fresh :: n -> Q (Name ns 'Unique)

  -- | User-friendly representation of the name
  showName :: n -> String

instance IsName (Name ns flavour) where
  fresh    = newName . nameBase
  showName = nameBase

instance IsName OverloadedName where
  fresh    = newName . getOverloadedName
  showName = getOverloadedName

{-------------------------------------------------------------------------------
  Extract metadata
-------------------------------------------------------------------------------}

-- | Extract metadata
--
-- Metadata is used for two purposes:
--
-- 1. Generics. In this case, this is used for things like generating JSON,
--    pretty-printing, etc. This means that scope resolution is not relevant.
-- 2. The quasi-quoter. The quasi-quoter needs to map field names to record
--    indices (this field is the @i@th field in the record). This means that the
--    field names in the metadata must be equal to the field names that the
--    user will use in the quasi-quote.
class ExtractMetadata n where
  termLevelMetadata :: n -> Q TH.Exp
  typeLevelMetadata :: n -> Q TH.Type

instance ExtractMetadata OverloadedName where
  termLevelMetadata (OverloadedName n) = TH.stringE n
  typeLevelMetadata (OverloadedName n) = TH.litT $ TH.strTyLit n

instance ExtractMetadata (Name ns flavour) where
  termLevelMetadata (Name (TH.OccName n) _) = TH.stringE n
  typeLevelMetadata (Name (TH.OccName n) _) = TH.litT $ TH.strTyLit n

{-------------------------------------------------------------------------------
  Thin layer around TH functions that take names
-------------------------------------------------------------------------------}

conE        :: Name 'DataName  flavour -> _
conT        :: Name 'TcClsName flavour -> _
patSynD     :: Name 'DataName 'Unique  -> _
patSynSigD  :: Name 'DataName 'Unique  -> _
recC        :: Name 'DataName 'Dynamic -> _
sigD        :: Name 'VarName  'Dynamic -> _
varBangType :: Name 'VarName  'Dynamic -> _
varE        :: Name 'VarName   flavour -> _
varP        :: Name 'VarName   flavour -> _

conE        = TH.conE        . toName
conT        = TH.conT        . toName
patSynD     = TH.patSynD     . toName
patSynSigD  = TH.patSynSigD  . toName
recC        = TH.recC        . toName
sigD        = TH.sigD        . toName
varBangType = TH.varBangType . toName
varE        = TH.varE        . toName
varP        = TH.varP        . toName

classD   :: _ -> Name 'TcClsName 'Dynamic -> _
newtypeD :: _ -> Name 'TcClsName 'Unique  -> _

classD   cxt = TH.classD   cxt . toName
newtypeD cxt = TH.newtypeD cxt . toName

recordPatSyn :: [OverloadedName] -> _
recordPatSyn = TH.recordPatSyn . map (toName . fromOverloaded)

pragCompleteD :: [Name 'DataName 'Unique] -> Maybe (Name 'TcClsName flavour) -> _
pragCompleteD constrs typ =
    TH.pragCompleteD (toName <$> constrs) (toName <$> typ)

{-------------------------------------------------------------------------------
  Internal auxiliary
-------------------------------------------------------------------------------}

-- | Qualify a name (for use in 'lookupTypeName' and co)
qualify :: Maybe TH.ModName -> TH.OccName -> String
qualify Nothing               (TH.OccName occ) = occ
qualify (Just (TH.ModName m)) (TH.OccName occ) = m ++ "." ++ occ
