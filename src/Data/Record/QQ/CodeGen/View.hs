{-# LANGUAGE DataKinds           #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TupleSections       #-}

-- | Our view on record expressions/patterns
--
-- This follows "Data.Record.TH.CodeGen.View" closely, but lacks global info
-- about the type (e.g., which class instances it derives). The only type info
-- we /do/ have is whatever we generate as part of the type-level metadata.
module Data.Record.QQ.CodeGen.View (
    -- * View
    Record(..)
  , Field(..)
    -- * Constructing the view
  , MatchedRecord(..)
  , matchRecordExp
  , matchRecordPat
    -- * Lower-level API
  , resolveConstr
  ) where

import Control.Monad.Except
import Control.Monad.State
import Data.List (sortBy)
import Data.Map (Map)
import Data.Ord (comparing)
import Language.Haskell.TH
import Language.Haskell.TH.Syntax

import qualified Data.Map            as Map
import qualified Data.Map.Merge.Lazy as Map

import Data.Record.QQ.CodeGen.Metadata
import Data.Record.TH.CodeGen.Name (TypeName, ConstrName, FieldName)

import qualified Data.Record.TH.CodeGen.Name as N

{-------------------------------------------------------------------------------
  Types
-------------------------------------------------------------------------------}

data Record a = Record {
      recordUnqual :: TypeName 'N.Global
    , recordTVars  :: [TyVarBndr]
    , recordConstr :: ConstrName 'N.Global
    , recordFields :: [Field a]
    }
  deriving (Show)

data Field a = Field {
      fieldUnqual :: FieldName
    , fieldType   :: Type
    , fieldIndex  :: Int
    , fieldDec    :: Maybe a -- ^ Nothing if not present
    }
  deriving (Show)

{-------------------------------------------------------------------------------
  Constructing the view
-------------------------------------------------------------------------------}

matchRecordExp :: Quasi m => Exp -> m (Maybe (MatchedRecord Exp))
matchRecordExp = traverse matchRecord <=< termExp

matchRecordPat :: Quasi m => Pat -> m (Maybe (MatchedRecord Pat))
matchRecordPat = traverse matchRecord <=< termPat

data MatchedRecord a =
    -- | The pattern/value we matched against is not a (known) large record
    NotKnownLargeRecord

    -- | The pattern/value has fields not present in the record definition
  | UnknownFields [FieldName]

    -- | Successfully matched against a known large records
    --
    -- Note that not all fields may have a corresponding value/pattern.
  | MatchedRecord (Record a)

-- | Try to match a pattern or expression against a (large) record
matchRecord ::
     forall m a. Quasi m
  => (ConstrName 'N.Global, [(FieldName, a)])
  -> m (MatchedRecord a)
matchRecord (constr, fields) = do
    mMetadata <- runExceptT $ getTypeLevelMetadata constr
    case mMetadata of
      Left _err ->
        return NotKnownLargeRecord
      Right (rType, (tyVars, fieldTypes)) ->
        return $
          case go rType tyVars fieldTypes of
            (r, [])      -> MatchedRecord r
            (_, unknown) -> UnknownFields unknown
  where
    go :: TypeName 'N.Global
       -> [TyVarBndr]
       -> [(FieldName, Type)]
       -> (Record a, [FieldName])
    go rType tyVars fieldTypes = (
          Record {
              recordUnqual = rType
            , recordTVars  = tyVars
            , recordConstr = constr
            , recordFields = sortBy (comparing fieldIndex) [
                  Field {
                      fieldUnqual = fName
                    , fieldType   = fType
                    , fieldIndex  = ix
                    , fieldDec    = fVal
                    }
                | (fName, (fType, ix, fVal)) <- Map.toList matched
                ]
            }
        , unknown
        )
      where
        expected :: Map FieldName (Type, Int)
        expected = Map.fromList $
            zipWith (\(nm, typ) ix -> (nm, (typ, ix))) fieldTypes [0..]

        actual :: Map FieldName a
        actual = Map.fromList fields

        matched :: Map FieldName (Type, Int, Maybe a)
        unknown :: [FieldName]
        (matched, unknown) = flip runState [] $
            Map.mergeA
              (Map.traverseMissing      fieldMissing)
              (Map.traverseMaybeMissing fieldUnknown)
              (Map.zipWithAMatched      fieldPresent)
              expected
              actual

    fieldPresent :: FieldName -> (Type, Int) -> a -> State [FieldName] (Type, Int, Maybe a)
    fieldPresent _nm (typ, ix) val = return (typ, ix, Just val)

    fieldMissing :: FieldName -> (Type, Int) -> State [FieldName] (Type, Int, Maybe a)
    fieldMissing _nm (typ, ix) = return (typ, ix, Nothing)

    fieldUnknown :: FieldName -> a -> State [FieldName] (Maybe (Type, Int, Maybe a))
    fieldUnknown nm _val = modify (nm:) >> return Nothing

{-------------------------------------------------------------------------------
  Match against the syntax tree generated by @haskell-src-exts@

  NOTE: Since this is using @haskell-src-exts@ rather than just a regular
  TH quote, these 'Names' have not been properly renamed. We therefore have to
  do a lookup here.
-------------------------------------------------------------------------------}

-- | Resolve constructor name
--
-- The name we get from @haskell-src-meta@ will have a dynamic flavour (in
-- other words, will not have been through the renamer), and so we must resolve
-- it here.
resolveConstr :: Quasi m => Name -> m (ConstrName 'N.Global)
resolveConstr n = do
    mConstr <- N.lookupName (N.ConstrName (N.fromName' n))
    case mConstr of
      Nothing      -> fail $ "resolveConstr: " ++ show n ++ " not in scope"
      Just constr' -> return constr'

termExp ::
     Quasi m
  => Exp -> m (Maybe (ConstrName 'N.Global, [(FieldName, Exp)]))
termExp (RecConE constr fields) = do
    constr' <- resolveConstr constr
    return $ Just (constr', map matchField fields)
termExp _otherwise =
   return Nothing

termPat ::
     Quasi m
  => Pat -> m (Maybe (ConstrName 'N.Global, [(FieldName, Pat)]))
termPat (RecP constr fields) = do
    constr' <- resolveConstr constr
    return $ Just (constr', map matchField fields)
termPat _otherwise =
    return Nothing

matchField :: (Name, a) -> (FieldName, a)
matchField (name, a) = (N.FieldName (N.OverloadedName (nameBase name)), a)

