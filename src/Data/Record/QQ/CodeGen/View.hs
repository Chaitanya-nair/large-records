{-# LANGUAGE DataKinds           #-}
{-# LANGUAGE ParallelListComp    #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TupleSections       #-}

-- | Our view on record expressions/patterns
--
-- This follows "Data.Record.TH.CodeGen.View" closely, but lacks global info
-- about the type (e.g., which class instances it derives). The only type info
-- we /do/ have is whatever we generate as part of the type-level metadata.
module Data.Record.QQ.CodeGen.View (
    -- * View
    Record(..)
  , Field(..)
    -- * Constructing the view
  , matchRecordExp
  , matchRecordPat
  ) where

import Data.Map (Map)
import Control.Monad.Except
import Language.Haskell.TH

import qualified Data.Map as Map

import Data.Record.QQ.CodeGen.Metadata
import Data.Record.TH.CodeGen.Name (TypeName, ConstrName, FieldName)

import qualified Data.Record.TH.CodeGen.Name as N

{-------------------------------------------------------------------------------
  Types
-------------------------------------------------------------------------------}

data Record a = Record {
      recordUnqual :: TypeName 'N.Global
    , recordTVars  :: [TyVarBndr]
    , recordConstr :: ConstrName 'N.Global
    , recordFields :: [Field a]
    }
  deriving (Show)

data Field a = Field {
      fieldUnqual :: FieldName
    , fieldType   :: Type
    , fieldIndex  :: Int
    , fieldDec    :: Maybe a -- ^ Nothing if not present
    }
  deriving (Show)

{-------------------------------------------------------------------------------
  Constructing the view
-------------------------------------------------------------------------------}

matchRecordExp :: Exp -> Q (Maybe (Record Exp))
matchRecordExp = matchRecord <=< termExp

matchRecordPat :: Pat -> Q (Maybe (Record Pat))
matchRecordPat = matchRecord <=< termPat

matchRecord ::
     forall a.
     Maybe (ConstrName 'N.Global, [(FieldName, a)])
  -> Q (Maybe (Record a))
matchRecord Nothing =
    -- Not a record term/pattern
    return Nothing
matchRecord (Just (constr, fields)) = do
    mMetadata <- runExceptT $ getTypeLevelMetadata constr
    case mMetadata of
      Left _err ->
        -- If we can't find any metadata, assume it's a regular record
        -- rather than a @large-records@ record, and return 'Nothing'
        return Nothing
      Right (rType, (tyVars, fieldTypes)) ->
        return $ Just Record {
            recordUnqual = rType
          , recordTVars  = tyVars
          , recordConstr = constr
          , recordFields = [
                Field {
                    fieldUnqual = fName
                  , fieldType   = fType
                  , fieldIndex  = ix
                  , fieldDec    = Map.lookup fName fields'
                  }
              | (fName, fType) <- fieldTypes
              | ix <- [0..]
              ]
          }
  where
    fields' :: Map FieldName a
    fields' = Map.fromList fields

{-------------------------------------------------------------------------------
  Match against the syntax tree generated by @haskell-src-exts@

  NOTE: Since this is using @haskell-src-exts@ rather than just a regular
  TH quote, these 'Names' have not been properly renamed. We therefore have to
  do a lookup here.
-------------------------------------------------------------------------------}

-- | Resolve constructor name
--
-- The name we get from @haskell-src-meta@ will have a dynamic flavour (in
-- other words, will not have been through the renamer), and so we must resolve
-- it here.
resolveConstr :: Name -> Q (ConstrName 'N.Global)
resolveConstr n = do
    mConstr <- N.lookupName (N.ConstrName (N.fromName' n))
    case mConstr of
      Nothing      -> fail $ "resolveConstr: " ++ show n ++ " not in scope"
      Just constr' -> return constr'

termExp :: Exp -> Q (Maybe (ConstrName 'N.Global, [(FieldName, Exp)]))
termExp (RecConE constr fields) = do
    constr' <- resolveConstr constr
    return $ Just (constr', map matchField fields)
termExp _otherwise =
   return Nothing

termPat :: Pat -> Q (Maybe (ConstrName 'N.Global, [(FieldName, Pat)]))
termPat (RecP constr fields) = do
    constr' <- resolveConstr constr
    return $ Just (constr', map matchField fields)
termPat _otherwise =
    return Nothing

matchField :: (Name, a) -> (FieldName, a)
matchField (name, a) = (N.FieldName (N.OverloadedName (nameBase name)), a)
