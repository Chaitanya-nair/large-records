{-# LANGUAGE DataKinds           #-}
{-# LANGUAGE ScopedTypeVariables #-}

module Data.Record.QQ.CodeGen.Parser (
    ParsedRecordInfo(..)
  , parseRecordExp
  , parseRecordPat
  ) where

import Control.Monad.State
import Language.Haskell.TH
import Language.Haskell.TH.Syntax

import Data.Record.Internal.RecordInfo
import Data.Record.Internal.RecordInfo.Resolution
import Data.Record.QQ.CodeGen.HSE

import qualified Data.Record.Internal.TH.Name as N

data ParsedRecordInfo a =
    -- | The pattern/value we matched against is not a (known) large record
    NotKnownLargeRecord

    -- | The pattern/value has fields not present in the record definition
  | UnknownFields [N.OverloadedName]

    -- | Successfully matched against a known large records
    --
    -- Note that not all fields may have a corresponding value/pattern.
  | ParsedRecordInfo (RecordInfo a)

parseRecordExp :: Quasi m => Exp -> m (Maybe (ParsedRecordInfo Exp))
parseRecordExp = traverse parseRecordInfo <=< termExp

parseRecordPat :: Quasi m => Pat -> m (Maybe (ParsedRecordInfo Pat))
parseRecordPat = traverse parseRecordInfo <=< termPat

-- | Try to match a pattern or expression against a (large) record
parseRecordInfo ::
     forall m a. Quasi m
  => (N.Name 'N.DataName 'N.Global, [(N.OverloadedName, a)])
  -> m (ParsedRecordInfo a)
parseRecordInfo (constr, fields) =
    aux . fmap (setRecordInfoValues fields) <$> resolveRecordInfo constr
  where
    aux :: Either String (RecordInfo a, [N.OverloadedName]) -> ParsedRecordInfo a
    aux (Left _err)          = NotKnownLargeRecord
    aux (Right (r, []))      = ParsedRecordInfo r
    aux (Right (_, unknown)) = UnknownFields unknown

{-------------------------------------------------------------------------------
  Match against the syntax tree generated by @haskell-src-exts@
-------------------------------------------------------------------------------}

termExp ::
     Quasi m
  => Exp -> m (Maybe (N.Name 'N.DataName 'N.Global, [(N.OverloadedName, Exp)]))
termExp (RecConE constr fields) = do
    constr' <- resolveConstr constr
    return $ Just (constr', map matchField fields)
termExp _otherwise =
   return Nothing

termPat ::
     Quasi m
  => Pat -> m (Maybe (N.Name 'N.DataName 'N.Global, [(N.OverloadedName, Pat)]))
termPat (RecP constr fields) = do
    constr' <- resolveConstr constr
    return $ Just (constr', map matchField fields)
termPat _otherwise =
    return Nothing

matchField :: (Name, a) -> (N.OverloadedName, a)
matchField (name, a) = (N.OverloadedName (nameBase name), a)

