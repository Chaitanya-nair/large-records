{-# LANGUAGE DataKinds             #-}
{-# LANGUAGE DerivingVia           #-}
{-# LANGUAGE FlexibleInstances     #-}
{-# LANGUAGE GADTs                 #-}
{-# LANGUAGE KindSignatures        #-}
{-# LANGUAGE PartialTypeSignatures #-}
{-# LANGUAGE ScopedTypeVariables   #-}
{-# LANGUAGE StandaloneDeriving    #-}

{-# OPTIONS_GHC -Wno-partial-type-signatures #-}

-- | Names with statically known flavour
--
-- Intended for qualified import
--
-- > import Data.Record.TH.CodeGen.Name (TypeName, ConstrName, FieldName)
-- > import qualified Data.Record.TH.CodeGen.Name as N
module Data.Record.TH.CodeGen.Name (
    -- * Names
    Flavour(..)
  , NameFlavour(..)
  , Name(..)
  , nameBase
    -- ** Singleton
  , SFlavour(..)
  , IsFlavour(..)
    -- ** Conversion
  , fromName
  , fromName'
  , toName
    -- * Overloaded names
  , OverloadedName(..)
  , FromOverloaded(..)
    -- * Specific kinds of names
  , TypeName(..)
  , ConstrName(..)
  , FieldName(..)
    -- * Resolution
  , LookupName(..)
  , Reify(..)
    -- * Construction
  , MkPrefixedName(..)
  , Fresh(..)
    -- * Metadata
  , ExtractMetadata(..)
    -- * Construct TH
  , classD
  , conE
  , conT
  , newtypeD
  , patSynD
  , patSynSigD
  , pragCompleteD
  , recC
  , recordPatSyn
  , sigD
  , varBangType
  , varE
  , varP
  ) where

import Data.Kind
import Data.Maybe (fromMaybe)
import Language.Haskell.TH (Q)

import qualified Language.Haskell.TH.Syntax as TH
import qualified Language.Haskell.TH.Lib    as TH

{-------------------------------------------------------------------------------
  Names
-------------------------------------------------------------------------------}

-- | Name flavours (used as a kind, not as a type)
--
-- Technically speaking there is one flavour missing: names that are locally
-- bound, but outside of the TH quote, something like
--
-- > foo x = [| .. x .. |]
--
-- However, we won't actually deal with such names.
data Flavour =
    -- | Dynamically bound
    --
    -- Dynamically bound names will be bound to a global name by @ghc@ after
    -- splicing the TH generated Haskelll code.
    --
    -- These are generated with 'mkName' (also used by @haskell-src-meta@).
    Dynamic

    -- | A new name
    --
    -- These are names either generated by 'newName' or are new names in a TH
    -- declaration quote @[d| ... |]@.
  | Unique

    -- | Reference to a specific name defined outside of the TH quote
  | Global

data NameFlavour :: Flavour -> Type where
  -- | Dynamically bound name, with an optional module prefix (@T.foo@)
  NameDynamic :: Maybe TH.ModName -> NameFlavour 'Dynamic

  -- | Unique local name
  NameUnique :: TH.Uniq -> NameFlavour 'Unique

  -- | Global name bound outside of the TH quot
  NameGlobal :: TH.NameSpace -> TH.PkgName -> TH.ModName -> NameFlavour 'Global

-- | Like TH's 'Name', but with statically known flavour.
data Name :: Flavour -> Type where
  Name :: TH.OccName -> NameFlavour flavour -> Name flavour

deriving instance Show (NameFlavour flavour)
deriving instance Show (Name        flavour)

deriving instance Eq (NameFlavour flavour)
deriving instance Eq (Name        flavour)

nameBase :: Name flavour -> String
nameBase (Name (TH.OccName occ) _) = occ

{-------------------------------------------------------------------------------
  Singleton
-------------------------------------------------------------------------------}

-- | Singleton type associated with 'Flavour'
data SFlavour :: Flavour -> Type where
  SDynamic :: SFlavour 'Dynamic
  SUnique  :: SFlavour 'Unique
  SGlobal  :: SFlavour 'Global

deriving instance Show (SFlavour flavour)

class IsFlavour flavour where
  isFlavour :: SFlavour flavour

instance IsFlavour 'Dynamic where isFlavour = SDynamic
instance IsFlavour 'Unique  where isFlavour = SUnique
instance IsFlavour 'Global  where isFlavour = SGlobal

{-------------------------------------------------------------------------------
  Conversion
-------------------------------------------------------------------------------}

toFlavourF :: SFlavour flavour -> TH.NameFlavour -> Maybe (NameFlavour flavour)
toFlavourF SDynamic (TH.NameS)       = Just $ NameDynamic Nothing
toFlavourF SDynamic (TH.NameQ m)     = Just $ NameDynamic (Just m)
toFlavourF SUnique  (TH.NameU u)     = Just $ NameUnique u
toFlavourF SGlobal  (TH.NameG n p m) = Just $ NameGlobal n p m
toFlavourF _        _                = Nothing

fromFlavourF :: NameFlavour flavour -> TH.NameFlavour
fromFlavourF (NameDynamic Nothing)  = TH.NameS
fromFlavourF (NameDynamic (Just m)) = TH.NameQ m
fromFlavourF (NameUnique u)         = TH.NameU u
fromFlavourF (NameGlobal n p m)     = TH.NameG n p m

-- | Translate from a dynamically typed TH name
--
-- Returns 'Nothing' if the TH name does not have the specified flavour.
fromName :: IsFlavour flavour => TH.Name -> Maybe (Name flavour)
fromName (TH.Name occ flavour') =
    Name occ <$> toFlavourF isFlavour flavour'

-- | Variation on 'fromName' that throws an exception on a flavour mismatch
fromName' :: forall flavour. IsFlavour flavour => TH.Name -> Name flavour
fromName' name@(TH.Name occ flavour') =
    fromMaybe (error err) $ fromName name
  where
    err :: String
    err = concat [
          "fromName': name "
        , show occ
        , " has the wrong flavour: "
        , show (isFlavour :: SFlavour flavour)
        , " /= "
        , show flavour'
        ]

class ToName (n :: Flavour -> Type) where
  toName :: forall flavour. n flavour -> TH.Name

instance ToName Name where
  toName (Name occ flavour) = TH.Name occ (fromFlavourF flavour)

{-------------------------------------------------------------------------------
  Overloaded names
-------------------------------------------------------------------------------}

-- | Overloaded name
--
-- Overloaded names only have an interpretation in context; for example, a
-- field name only means something when combined with type of the /record/ the
-- field belongs to.
--
-- We treat this as a completely separate category, because 'OverloadedName's
-- do not correspond to TH 'Name's.
newtype OverloadedName = OverloadedName {
      getOverloadedName :: String
    }
  deriving (Show, Eq, Ord)

class FromOverloaded n where
  -- | Construct 'Name' from an 'OverloadedName'
  --
  -- WARNING: The moment you do this, you lose overloading: using 'fromOverloaded'
  -- to bind definitions for two fields with the same name will result in two
  -- identical names within the same scope, and hence a "multiple declarations"
  -- error.
  fromOverloaded :: n -> Name 'Dynamic

instance FromOverloaded OverloadedName where
  fromOverloaded (OverloadedName n) = mkName n

{-------------------------------------------------------------------------------
  Specific kinds of names
-------------------------------------------------------------------------------}

newtype TypeName flavour = TypeName {
      getTypeName :: Name flavour
    }
  deriving (Show, Eq)
  deriving (Reify, MkPrefixedName, ToName) via Name
  deriving ExtractMetadata via Name flavour

newtype ConstrName flavour = ConstrName {
      getConstrName :: Name flavour
    }
  deriving (Show, Eq)
  deriving (Reify, MkPrefixedName, ToName) via Name
  deriving ExtractMetadata via Name flavour

newtype FieldName = FieldName {
      getFieldName :: OverloadedName
    }
  deriving (Show, Eq, Ord)
  deriving (FromOverloaded, Fresh) via OverloadedName

{-------------------------------------------------------------------------------
  Resolution
-------------------------------------------------------------------------------}

class LookupName (n :: Flavour -> Type) where
  lookupName :: n 'Dynamic -> Q (Maybe (n 'Global))

instance LookupName TypeName where
  lookupName (TypeName (Name occ (NameDynamic mMod))) =
      fmap (TypeName . fromName') <$>
        TH.lookupTypeName (qualify mMod occ)

instance LookupName ConstrName where
  lookupName (ConstrName (Name occ (NameDynamic mMod))) =
      fmap (ConstrName . fromName') <$>
        TH.lookupValueName (qualify mMod occ)

class Reify (n :: Flavour -> Type) where
  -- | Get info about the given name
  --
  -- Only global names can be reified. See 'lookupName'.
  reify :: n 'Global -> Q TH.Info

instance Reify Name where
  reify = TH.reify . toName

{-------------------------------------------------------------------------------
  Construction
-------------------------------------------------------------------------------}

newName :: String -> Q (Name 'Unique)
newName = fmap fromName' . TH.newName

mkName :: String -> Name 'Dynamic
mkName = fromName' . TH.mkName

class MkPrefixedName (n :: Flavour -> Type) where
  -- | Construct a new (dynamically bound) name by prefixing another name
  --
  -- Only the base name ('OccName') of the input name will be used.
  prefixNew :: String -> n 'Unique -> Name 'Dynamic

  -- | When we prefix an existing name, we want to use the package/module
  -- info of the existing name, but not necessarily it's namespace: we might
  -- well be deriving, say, a function name from a type name.
  prefixExisting :: String -> TH.NameSpace -> n 'Global ->  Name 'Global

instance MkPrefixedName Name where
  prefixNew prefix (Name (TH.OccName occ) _flavour) =
      Name (TH.OccName (prefix ++ occ)) (NameDynamic Nothing)

  prefixExisting prefix n (Name (TH.OccName occ) (NameGlobal _ p m)) =
      Name (TH.OccName (prefix ++ occ)) (NameGlobal n p m)

class Fresh n where
  -- Make a fresh name derived from another name
  fresh :: n -> Q (Name 'Unique)

instance Fresh (Name flavour) where
  fresh = newName . nameBase

instance Fresh OverloadedName where
  fresh = newName . getOverloadedName

{-------------------------------------------------------------------------------
  Extract metadata
-------------------------------------------------------------------------------}

-- | Extract metadata
--
-- Metadata is used for two purposes:
--
-- 1. Generics. In this case, this is used for things like generating JSON,
--    pretty-printing, etc. This means that scope resolution is not relevant.
-- 2. The quasi-quoter. The quasi-quoter needs to map field names to record
--    indices (this field is the @i@th field in the record). This means that the
--    field names in the metadata must be equal to the field names that the
--    user will use in the quasi-quote.
class ExtractMetadata n where
  termLevelMetadata :: n -> Q TH.Exp
  typeLevelMetadata :: n -> Q TH.Type

instance ExtractMetadata FieldName where
  termLevelMetadata (FieldName (OverloadedName n)) = TH.stringE n
  typeLevelMetadata (FieldName (OverloadedName n)) = TH.litT $ TH.strTyLit n

instance ExtractMetadata (Name flavour) where
  termLevelMetadata (Name (TH.OccName n) _) = TH.stringE n
  typeLevelMetadata (Name (TH.OccName n) _) = TH.litT $ TH.strTyLit n

{-------------------------------------------------------------------------------
  Thin layer around TH functions that take names
-------------------------------------------------------------------------------}

conE        :: ConstrName  flavour -> _
conT        :: Name        flavour -> _
patSynD     :: ConstrName 'Unique  -> _
patSynSigD  :: ConstrName 'Unique  -> _
recC        :: ConstrName 'Dynamic -> _
sigD        :: Name       'Dynamic -> _
varBangType :: Name       'Dynamic -> _
varE        :: Name        flavour -> _
varP        :: Name        flavour -> _

conE        = TH.conE        . toName
conT        = TH.conT        . toName
patSynD     = TH.patSynD     . toName
patSynSigD  = TH.patSynSigD  . toName
recC        = TH.recC        . toName
sigD        = TH.sigD        . toName
varBangType = TH.varBangType . toName
varE        = TH.varE        . toName
varP        = TH.varP        . toName

classD   :: _ -> Name     'Dynamic -> _
newtypeD :: _ -> TypeName 'Unique  -> _

classD   cxt = TH.classD   cxt . toName
newtypeD cxt = TH.newtypeD cxt . toName

recordPatSyn :: [FieldName] -> _
recordPatSyn = TH.recordPatSyn . map (toName . fromOverloaded)

pragCompleteD :: [ConstrName 'Unique] -> Maybe (TypeName flavour) -> _
pragCompleteD constrs typ =
    TH.pragCompleteD (toName <$> constrs) (toName <$> typ)

{-------------------------------------------------------------------------------
  Internal auxiliary
-------------------------------------------------------------------------------}

-- | Qualify a name (for use in 'lookupTypeName' and co)
qualify :: Maybe TH.ModName -> TH.OccName -> String
qualify Nothing               (TH.OccName occ) = occ
qualify (Just (TH.ModName m)) (TH.OccName occ) = m ++ "." ++ occ
